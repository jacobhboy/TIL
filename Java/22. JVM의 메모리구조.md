 // 아직 완벽하게 이해를 하지 못했다...

### JVM(Java Virtual Machine)이란?
> 자바가상머신, 한번작성해서 어디서든 실행 

----
### 자바 프로그램의 실행 단계

![](https://velog.velcdn.com/images/jacobhboy/post/c990b64a-6bf8-4fcb-b1b6-9c924595b66c/image.png)

1. 자바 컴파일러에 의해 자바 소스파일은 바이트 코드로 변환됨
2. 이러한 바이트 코드를 JVM에서 읽어 들인다.
3. 이것저것... 복잡한 과정을 거쳐 어떤 운영체제든간에 프로그램 실행할 수 있도록 만든다

---

### JVM 메모리 구조

위에서 말한 이것저것... 복잡한 구조를 알아보자!
![](https://velog.velcdn.com/images/jacobhboy/post/efefb9e3-dfa7-4cdb-8d70-8372ac737bcb/image.png)

#### 1. Class Loader
`JVM내로 클래스 파일 로드`, `링크통해 배치하는 작업`을 수행하는 모듈 | 런타임 시에 동적으로 클래스를 로드

#### 2. Execution Engine
클래스 로더를 통해 JVM 내의 Runtime Data Area에 배치된 `바이트 코드들을 명렁어 단위로 읽어서 실행`

#### 3. Garbage Collector(CG)
힙 메모리 영역에 생성된 객체들 중에서 `참조되지 않은 객체들을 탐색 후 제거`하는 역할
CG가 역할을 하는 시간은 언제인지 알 수 없다.

#### 4. Runtime Data Area
JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 `사용되는 데이터들을 적재`하는 영역

---

### Runtime Data Area 내부에서

#### 1. Meathod area 
모든 쓰레드가 공유하는 메모리 영역(클래스, 인터페이스, 메소드, 필드. Static변수등의 바이트 코드를 보관)

#### 2. Heap area
모든 쓰레드가 공유하며, `new 키워드로 생성된 객체와 배열이 생성되는 영역` | 메소드 영역에 로드된 클래스만 생성이 가능 | `Garbage Collector가 참조되지 않는 메모리 확인하고 제거`

#### 3. Stack area
메서드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성 | 메서드 안에서 사용되는 값들을 저장, 호출된 메서드의 매개변수, 지역변수, 리턴 값등을 임시로 저장 메서드 수행이 끝나면 프레임별로 삭제

#### 4. PC Register
쓰레드가 시작될 때 생성되며, 생성될 때마다 생성되는 공간으로 쓰레드마다 하나씩 존재합니다. 쓰레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 명령의 주소를 갖는다










